<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Social Network Visualizer code annotation: Matrix Class Reference</title>
<meta name="keywords" content="manual,social network analysis software, Social Network Visualizer, social network analysis, SocNetV, graphs, social network visualization, network layout, social network analysis tool, social network analysis datasets, centrality, graph theory" />
<meta name="trademark" content="SocNetV" />
<meta name="AUTHOR" content="Dimitris Kalamaras" />
<meta name="ROBOTS" content="INDEX, FOLLOW" />
<meta name="revisit-after" content="1 days" />
<meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="pragma" content="no-cache" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-H02ELBFZMN"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-H02ELBFZMN');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="socnetv-logo-manual.png"/></td>
  <td id="projectalign">
   <div id="projectname">Social Network Visualizer<span id="projectnumber">&#160;3.1</span>
   </div>
   <div id="projectbrief">Source code annotation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classMatrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">Matrix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="matrix_8h_source.html">matrix.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Matrix:</div>
<div class="dyncontent">
<div class="center"><img src="classMatrix__coll__graph.png" border="0" usemap="#aMatrix_coll__map" alt="Collaboration graph"/></div>
<map name="aMatrix_coll__map" id="aMatrix_coll__map">
<area shape="rect" title=" " alt="" coords="19,93,77,119"/>
<area shape="rect" href="classMatrixRow.html" title=" " alt="" coords="5,5,91,31"/>
<area shape="poly" title=" " alt="" coords="51,45,51,93,45,93,45,45"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b5cc0016481d9e834a1b116507ca5f0" id="r_a9b5cc0016481d9e834a1b116507ca5f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a9b5cc0016481d9e834a1b116507ca5f0">Matrix</a> (int rowDim=0, int colDim=0)</td></tr>
<tr class="memdesc:a9b5cc0016481d9e834a1b116507ca5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html#a9b5cc0016481d9e834a1b116507ca5f0" title="Matrix::Matrix Default constructor - creates a Matrix of given dimension (0x0) Use resize(m,...">Matrix::Matrix</a> Default constructor - creates a <a class="el" href="classMatrix.html">Matrix</a> of given dimension (0x0) Use resize(m,n) or zeromatrix(m,n) to resize it.  <br /></td></tr>
<tr class="separator:a9b5cc0016481d9e834a1b116507ca5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086a20e89f81f1e6f1807e8198993620" id="r_a086a20e89f81f1e6f1807e8198993620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a086a20e89f81f1e6f1807e8198993620">Matrix</a> (const <a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a086a20e89f81f1e6f1807e8198993620"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html#a9b5cc0016481d9e834a1b116507ca5f0" title="Matrix::Matrix Default constructor - creates a Matrix of given dimension (0x0) Use resize(m,...">Matrix::Matrix</a> Copy constructor. Creates a <a class="el" href="classMatrix.html">Matrix</a> identical to <a class="el" href="classMatrix.html">Matrix</a> b Allows <a class="el" href="classMatrix.html">Matrix</a> a=b declaration Every <a class="el" href="classMatrixRow.html">MatrixRow</a> object holds max_int=32762.  <br /></td></tr>
<tr class="separator:a086a20e89f81f1e6f1807e8198993620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1c3627f573d78a2f08623fdfef990f" id="r_a9b1c3627f573d78a2f08623fdfef990f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a9b1c3627f573d78a2f08623fdfef990f">~Matrix</a> ()</td></tr>
<tr class="memdesc:a9b1c3627f573d78a2f08623fdfef990f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html#a9b1c3627f573d78a2f08623fdfef990f" title="Matrix::~Matrix Destructor.">Matrix::~Matrix</a> Destructor.  <br /></td></tr>
<tr class="separator:a9b1c3627f573d78a2f08623fdfef990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e2adb05e204d5a40cd129d9fb0593f" id="r_ac0e2adb05e204d5a40cd129d9fb0593f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ac0e2adb05e204d5a40cd129d9fb0593f">clear</a> ()</td></tr>
<tr class="memdesc:ac0e2adb05e204d5a40cd129d9fb0593f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears data.  <br /></td></tr>
<tr class="separator:ac0e2adb05e204d5a40cd129d9fb0593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46f39a935b8209013bb6ba1211d3a2" id="r_a3f46f39a935b8209013bb6ba1211d3a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a3f46f39a935b8209013bb6ba1211d3a2">resize</a> (const int m, const int n)</td></tr>
<tr class="memdesc:a3f46f39a935b8209013bb6ba1211d3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this matrix to m x n Called before every operation on new matrices. Every <a class="el" href="classMatrixRow.html">MatrixRow</a> object holds max_int=32762.  <br /></td></tr>
<tr class="separator:a3f46f39a935b8209013bb6ba1211d3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9348504c25d9f54b065c567c9deaef" id="r_acf9348504c25d9f54b065c567c9deaef"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#acf9348504c25d9f54b065c567c9deaef">item</a> (int r, int c)</td></tr>
<tr class="memdesc:acf9348504c25d9f54b065c567c9deaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (r,c) matrix element.  <br /></td></tr>
<tr class="separator:acf9348504c25d9f54b065c567c9deaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f17622afe35fa3f6a0e07fcf08b8d6" id="r_a62f17622afe35fa3f6a0e07fcf08b8d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a62f17622afe35fa3f6a0e07fcf08b8d6">setItem</a> (const int r, const int c, const qreal elem)</td></tr>
<tr class="memdesc:a62f17622afe35fa3f6a0e07fcf08b8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the (r,c) matrix element calling the setColumn method.  <br /></td></tr>
<tr class="separator:a62f17622afe35fa3f6a0e07fcf08b8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81491e32603914aae2e302a3594faf8" id="r_ae81491e32603914aae2e302a3594faf8"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ae81491e32603914aae2e302a3594faf8">operator()</a> (const int r, const int c)</td></tr>
<tr class="separator:ae81491e32603914aae2e302a3594faf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a1562ebf9d783834024dc88131631" id="r_aaa4a1562ebf9d783834024dc88131631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixRow.html">MatrixRow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#aaa4a1562ebf9d783834024dc88131631">operator[]</a> (const int &amp;r)</td></tr>
<tr class="separator:aaa4a1562ebf9d783834024dc88131631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d72e265a32cf6fc0256392a076d647" id="r_ab6d72e265a32cf6fc0256392a076d647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ab6d72e265a32cf6fc0256392a076d647">clearItem</a> (int r, int c)</td></tr>
<tr class="memdesc:ab6d72e265a32cf6fc0256392a076d647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the (r,c) matrix element.  <br /></td></tr>
<tr class="separator:ab6d72e265a32cf6fc0256392a076d647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35649f43610688d020b2cad91f616d51" id="r_a35649f43610688d020b2cad91f616d51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a35649f43610688d020b2cad91f616d51">cols</a> ()</td></tr>
<tr class="separator:a35649f43610688d020b2cad91f616d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9c23e5ff5e2456a8d48024ab19fe96" id="r_add9c23e5ff5e2456a8d48024ab19fe96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#add9c23e5ff5e2456a8d48024ab19fe96">rows</a> ()</td></tr>
<tr class="separator:add9c23e5ff5e2456a8d48024ab19fe96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e960a1c6e8f5aa90dddb18d9394890c" id="r_a7e960a1c6e8f5aa90dddb18d9394890c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a7e960a1c6e8f5aa90dddb18d9394890c">size</a> ()</td></tr>
<tr class="separator:a7e960a1c6e8f5aa90dddb18d9394890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48d85988859bc436cbb69b0111f2ca5" id="r_ab48d85988859bc436cbb69b0111f2ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ab48d85988859bc436cbb69b0111f2ca5">findMinMaxValues</a> (qreal &amp;min, qreal &amp;max, bool &amp;hasRealNumbers)</td></tr>
<tr class="memdesc:ab48d85988859bc436cbb69b0111f2ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds Min-Max values in current <a class="el" href="classMatrix.html">Matrix</a>  <br /></td></tr>
<tr class="separator:ab48d85988859bc436cbb69b0111f2ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263c9e49df2a476afec20d2dce404497" id="r_a263c9e49df2a476afec20d2dce404497"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a263c9e49df2a476afec20d2dce404497">NeighboursNearestFarthest</a> (qreal &amp;min, qreal &amp;max, int &amp;imin, int &amp;jmin, int &amp;imax, int &amp;jmax)</td></tr>
<tr class="memdesc:a263c9e49df2a476afec20d2dce404497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classMatrix.html#ab48d85988859bc436cbb69b0111f2ca5" title="finds Min-Max values in current Matrix">Matrix::findMinMaxValues</a> only it skips r==c.  <br /></td></tr>
<tr class="separator:a263c9e49df2a476afec20d2dce404497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad031e4cac2d7564347c8870cfb08e840" id="r_ad031e4cac2d7564347c8870cfb08e840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ad031e4cac2d7564347c8870cfb08e840">deleteRowColumn</a> (int i)</td></tr>
<tr class="memdesc:ad031e4cac2d7564347c8870cfb08e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes row and column and shifts rows and cols accordingly.  <br /></td></tr>
<tr class="separator:ad031e4cac2d7564347c8870cfb08e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e3219050552b2f9683be6a4662292b" id="r_a50e3219050552b2f9683be6a4662292b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a50e3219050552b2f9683be6a4662292b">identityMatrix</a> (int dim)</td></tr>
<tr class="memdesc:a50e3219050552b2f9683be6a4662292b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this square matrix the identity square matrix I.  <br /></td></tr>
<tr class="separator:a50e3219050552b2f9683be6a4662292b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda39cf7bbe9a7409386a6e36cb2f558" id="r_acda39cf7bbe9a7409386a6e36cb2f558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#acda39cf7bbe9a7409386a6e36cb2f558">zeroMatrix</a> (const int m, const int n)</td></tr>
<tr class="memdesc:acda39cf7bbe9a7409386a6e36cb2f558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this matrix the zero matrix of size mxn.  <br /></td></tr>
<tr class="separator:acda39cf7bbe9a7409386a6e36cb2f558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ff4e4b97b1f412b6ba94fc57ab7a2" id="r_a335ff4e4b97b1f412b6ba94fc57ab7a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a335ff4e4b97b1f412b6ba94fc57ab7a2">fillMatrix</a> (qreal value)</td></tr>
<tr class="memdesc:a335ff4e4b97b1f412b6ba94fc57ab7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a matrix with a given value.  <br /></td></tr>
<tr class="separator:a335ff4e4b97b1f412b6ba94fc57ab7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa637521475da1b4e7e215de25b2f6b16" id="r_aa637521475da1b4e7e215de25b2f6b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#aa637521475da1b4e7e215de25b2f6b16">subtractFromI</a> ()</td></tr>
<tr class="memdesc:aa637521475da1b4e7e215de25b2f6b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts this matrix from I and returns.  <br /></td></tr>
<tr class="separator:aa637521475da1b4e7e215de25b2f6b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d865d3beaec2cce97db3dbcfa42646" id="r_ae8d865d3beaec2cce97db3dbcfa42646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ae8d865d3beaec2cce97db3dbcfa42646">operator=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a)</td></tr>
<tr class="memdesc:ae8d865d3beaec2cce97db3dbcfa42646"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> equality/assignment , operator = Allows copying a matrix onto another using b=a where b,a matrices Equals two matrices.  <br /></td></tr>
<tr class="separator:ae8d865d3beaec2cce97db3dbcfa42646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7680b5e35607556088d94101bedf82" id="r_a1e7680b5e35607556088d94101bedf82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a1e7680b5e35607556088d94101bedf82">sum</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a, <a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a1e7680b5e35607556088d94101bedf82"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> addition Takes two (nxn) matrices and returns their sum as a reference to this Same algorithm as operator +, just different interface. In this case, you use something like: c.sum(a,b)  <br /></td></tr>
<tr class="separator:a1e7680b5e35607556088d94101bedf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3c8d544c682255888602203ad4f76c" id="r_abb3c8d544c682255888602203ad4f76c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#abb3c8d544c682255888602203ad4f76c">operator+=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:abb3c8d544c682255888602203ad4f76c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html#abb3c8d544c682255888602203ad4f76c" title="Matrix::operator += Matrix add another matrix: += Adds to this matrix another matrix B of the same di...">Matrix::operator +=</a> <a class="el" href="classMatrix.html">Matrix</a> add another matrix: += Adds to this matrix another matrix B of the same dim and returns to this Allows A+=B.  <br /></td></tr>
<tr class="separator:abb3c8d544c682255888602203ad4f76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ed296536f062f5857e1e5550093890" id="r_ae0ed296536f062f5857e1e5550093890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ae0ed296536f062f5857e1e5550093890">operator+</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:ae0ed296536f062f5857e1e5550093890"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> addition, operator + Adds this matrix and B of the same dim and returns the sum S Allows S = A+B.  <br /></td></tr>
<tr class="separator:ae0ed296536f062f5857e1e5550093890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982dfa156a7e026fdf32f9cb3a7aa341" id="r_a982dfa156a7e026fdf32f9cb3a7aa341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a982dfa156a7e026fdf32f9cb3a7aa341">operator-</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a982dfa156a7e026fdf32f9cb3a7aa341"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> subtraction, operator - Subtract this matrix - B of the same dim and returns the result S Allows S = A-B.  <br /></td></tr>
<tr class="separator:a982dfa156a7e026fdf32f9cb3a7aa341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a024b6ea1ea94c6293a829689c92cdb" id="r_a2a024b6ea1ea94c6293a829689c92cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a2a024b6ea1ea94c6293a829689c92cdb">operator*</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a2a024b6ea1ea94c6293a829689c92cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> multiplication, operator * Multiplies (right) this matrix with given matrix b. Allows P = A * B where A,B of same dimension and returns product as a reference to the calling object.  <br /></td></tr>
<tr class="separator:a2a024b6ea1ea94c6293a829689c92cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02aa856e2460a5110376a3682a20935e" id="r_a02aa856e2460a5110376a3682a20935e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a02aa856e2460a5110376a3682a20935e">operator*=</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a02aa856e2460a5110376a3682a20935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies (right) this m x n matrix with given n x p matrix b and returns the product in the calling matrix which becomes an m x p matrix. This convenience operator *= allows A *= B.  <br /></td></tr>
<tr class="separator:a02aa856e2460a5110376a3682a20935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9363be8aae4aa23516e1c3475e4902e9" id="r_a9363be8aae4aa23516e1c3475e4902e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a9363be8aae4aa23516e1c3475e4902e9">product</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;A, <a class="el" href="classMatrix.html">Matrix</a> &amp;B, bool symmetry=false)</td></tr>
<tr class="memdesc:a9363be8aae4aa23516e1c3475e4902e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classMatrix.html">Matrix</a> Multiplication. Given two matrices A (mxn) and B (nxp) computes their product and stores it to the calling matrix which becomes an m x p matrix Allows P.product(A, B)  <br /></td></tr>
<tr class="separator:a9363be8aae4aa23516e1c3475e4902e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b7242fbf4ad8f420088894ce4ee0ac" id="r_a79b7242fbf4ad8f420088894ce4ee0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a79b7242fbf4ad8f420088894ce4ee0ac">productSym</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a, <a class="el" href="classMatrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="memdesc:a79b7242fbf4ad8f420088894ce4ee0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes two ( N x N ) matrices (symmetric) and outputs an upper triangular matrix.  <br /></td></tr>
<tr class="separator:a79b7242fbf4ad8f420088894ce4ee0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e73d5e98817e12b82a3f626c8343de" id="r_ac0e73d5e98817e12b82a3f626c8343de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ac0e73d5e98817e12b82a3f626c8343de">swapRows</a> (int rowA, int rowB)</td></tr>
<tr class="memdesc:ac0e73d5e98817e12b82a3f626c8343de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps row A with row B of this matrix.  <br /></td></tr>
<tr class="separator:ac0e73d5e98817e12b82a3f626c8343de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4817d5f0980756d72092a2c50a36c" id="r_afac4817d5f0980756d72092a2c50a36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#afac4817d5f0980756d72092a2c50a36c">multiplyScalar</a> (const qreal &amp;f)</td></tr>
<tr class="memdesc:afac4817d5f0980756d72092a2c50a36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar Multiplication. Multiplies this by qreal f and returns the product matrix of the same dim Allows to use P.multiplyScalar(f)  <br /></td></tr>
<tr class="separator:afac4817d5f0980756d72092a2c50a36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292e782a2e80d0e8582ba6999a8cc737" id="r_a292e782a2e80d0e8582ba6999a8cc737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a292e782a2e80d0e8582ba6999a8cc737">multiplyRow</a> (int <a class="el" href="classMatrix.html#a60c5ba9f9ca2c6fa3655133f6ef0acdb">row</a>, qreal value)</td></tr>
<tr class="memdesc:a292e782a2e80d0e8582ba6999a8cc737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply every element of row by value.  <br /></td></tr>
<tr class="separator:a292e782a2e80d0e8582ba6999a8cc737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf864c48534cf7e00563c72cadc32a2" id="r_afdf864c48534cf7e00563c72cadc32a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#afdf864c48534cf7e00563c72cadc32a2">productByVector</a> (qreal in[], qreal out[], const bool &amp;leftMultiply=false)</td></tr>
<tr class="memdesc:afdf864c48534cf7e00563c72cadc32a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the matrix-by-vector product Ax of this matrix Default product: Ax if leftMultiply=true then it returns the left product xA.  <br /></td></tr>
<tr class="separator:afdf864c48534cf7e00563c72cadc32a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82da700fb408afed1883cc70fcfed906" id="r_a82da700fb408afed1883cc70fcfed906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a82da700fb408afed1883cc70fcfed906">pow</a> (int n, bool symmetry=false)</td></tr>
<tr class="memdesc:a82da700fb408afed1883cc70fcfed906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-nth power of this matrix.  <br /></td></tr>
<tr class="separator:a82da700fb408afed1883cc70fcfed906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3d752d7b307582b5c34af1cc468df7" id="r_a0f3d752d7b307582b5c34af1cc468df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a0f3d752d7b307582b5c34af1cc468df7">expBySquaring2</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;Y, <a class="el" href="classMatrix.html">Matrix</a> &amp;X, int n, bool symmetry=false)</td></tr>
<tr class="memdesc:a0f3d752d7b307582b5c34af1cc468df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive algorithm implementing "Exponentiation by squaring". Also known as Fast Modulo Multiplication, this algorithm allows fast computation of a large power n of square matrix X.  <br /></td></tr>
<tr class="separator:a0f3d752d7b307582b5c34af1cc468df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772e644ebf88c4db20141d9453892d84" id="r_a772e644ebf88c4db20141d9453892d84"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a772e644ebf88c4db20141d9453892d84">distanceManhattan</a> (qreal x[], qreal y[], int n)</td></tr>
<tr class="memdesc:a772e644ebf88c4db20141d9453892d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, takes to vectors and returns their Manhattan distance (also known as l1 norm, Taxicab or L1 distance) which is the sum of the absolute differences of their coordinates.  <br /></td></tr>
<tr class="separator:a772e644ebf88c4db20141d9453892d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fc9e95ee2d9d9b18a12abdc95e27dd" id="r_a68fc9e95ee2d9d9b18a12abdc95e27dd"><td class="memItemLeft" align="right" valign="top">qreal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a68fc9e95ee2d9d9b18a12abdc95e27dd">distanceEuclidean</a> (qreal x[], int n)</td></tr>
<tr class="memdesc:a68fc9e95ee2d9d9b18a12abdc95e27dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, computes the Euclideian length (also known as L2 distance) of a vector: if x = (x1 x2 ... xn), then ||x|| = square_root(x1*x1 + x2*x2 + ... + xn*xn)  <br /></td></tr>
<tr class="separator:a68fc9e95ee2d9d9b18a12abdc95e27dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad3327d203585b13e758dff8e1ad4a8" id="r_a2ad3327d203585b13e758dff8e1ad4a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a2ad3327d203585b13e758dff8e1ad4a8">powerIteration</a> (qreal x[], qreal &amp;xsum, qreal &amp;xmax, int &amp;xmaxi, qreal &amp;xmin, int &amp;xmini, const qreal eps, const int &amp;maxIter)</td></tr>
<tr class="memdesc:a2ad3327d203585b13e758dff8e1ad4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the Power method which computes the leading eigenvector x of this matrix, that is the eigenvector corresponding to the largest positive eigenvalue. In the process, it also computes min and max values. Used by Eigenvector Centrality (EVC). We use C arrays instead of std::vectors or anything else, as we know from start the size (n) of vectors x and tmp This approach is faster than using std::vector when n &gt; 1000.  <br /></td></tr>
<tr class="separator:a2ad3327d203585b13e758dff8e1ad4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270bc5fddb676f9f54e4a29ed2162f9" id="r_ab270bc5fddb676f9f54e4a29ed2162f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ab270bc5fddb676f9f54e4a29ed2162f9">degreeMatrix</a> ()</td></tr>
<tr class="memdesc:ab270bc5fddb676f9f54e4a29ed2162f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Degree <a class="el" href="classMatrix.html">Matrix</a> of this matrix. The Degree <a class="el" href="classMatrix.html">Matrix</a> is diagonal matrix which contains information about the degree of each graph vertex (row of the adjacency matrix) Allows S = A.degreeMatrix()  <br /></td></tr>
<tr class="separator:ab270bc5fddb676f9f54e4a29ed2162f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bf675c54d9282b437a708ad86b37ad" id="r_a42bf675c54d9282b437a708ad86b37ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a42bf675c54d9282b437a708ad86b37ad">laplacianMatrix</a> ()</td></tr>
<tr class="memdesc:a42bf675c54d9282b437a708ad86b37ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Laplacian of this matrix. The Laplacian is a NxN matrix L = D - A where D is the degree matrix of A Allows S = A.laplacianMatrix()  <br /></td></tr>
<tr class="separator:a42bf675c54d9282b437a708ad86b37ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad609fedfd61e93679803bb114e544569" id="r_ad609fedfd61e93679803bb114e544569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ad609fedfd61e93679803bb114e544569">transpose</a> ()</td></tr>
<tr class="memdesc:ad609fedfd61e93679803bb114e544569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Transpose of this matrix Allows T = A.transpose()  <br /></td></tr>
<tr class="separator:ad609fedfd61e93679803bb114e544569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf2889831de95e3e045c60f8db0122" id="r_a3caf2889831de95e3e045c60f8db0122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a3caf2889831de95e3e045c60f8db0122">cocitationMatrix</a> ()</td></tr>
<tr class="memdesc:a3caf2889831de95e3e045c60f8db0122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Cocitation <a class="el" href="classMatrix.html">Matrix</a> of this matrix (C = A * A^T) Allows T = A.cocitationMatrix()  <br /></td></tr>
<tr class="separator:a3caf2889831de95e3e045c60f8db0122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec5d4a1f06ad0c8a9787e73641a9a9" id="r_ab1ec5d4a1f06ad0c8a9787e73641a9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ab1ec5d4a1f06ad0c8a9787e73641a9a9">inverseByGaussJordanElimination</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a)</td></tr>
<tr class="memdesc:ab1ec5d4a1f06ad0c8a9787e73641a9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts given matrix A by Gauss Jordan elimination Input: matrix A Output: matrix A becomes unit matrix this becomes the invert of A and is returned back.  <br /></td></tr>
<tr class="separator:ab1ec5d4a1f06ad0c8a9787e73641a9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30645e0907e08bd26a92607773d20f4d" id="r_a30645e0907e08bd26a92607773d20f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a30645e0907e08bd26a92607773d20f4d">inverse</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a)</td></tr>
<tr class="memdesc:a30645e0907e08bd26a92607773d20f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the inverse of given matrix a Allows b.inverse(a)  <br /></td></tr>
<tr class="separator:a30645e0907e08bd26a92607773d20f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3c70b5ced4aff37457087c03e50052" id="r_a9c3c70b5ced4aff37457087c03e50052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a9c3c70b5ced4aff37457087c03e50052">solve</a> (qreal b[])</td></tr>
<tr class="memdesc:a9c3c70b5ced4aff37457087c03e50052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the solution of the set of n linear equations A·x = b Allows A.solve(b)  <br /></td></tr>
<tr class="separator:a9c3c70b5ced4aff37457087c03e50052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a403dce8bf4ee2cbda5cded9b1ff1ab" id="r_a6a403dce8bf4ee2cbda5cded9b1ff1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a6a403dce8bf4ee2cbda5cded9b1ff1ab">ludcmp</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a, const int &amp;n, int indx[], qreal &amp;d)</td></tr>
<tr class="memdesc:a6a403dce8bf4ee2cbda5cded9b1ff1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given matrix a, it replaces a by the LU decomposition of a rowwise permutation of itself. Used in combination with lubksb to solve linear equations or invert a matrix.  <br /></td></tr>
<tr class="separator:a6a403dce8bf4ee2cbda5cded9b1ff1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a87971f24dc5247a8711a36903b751" id="r_a50a87971f24dc5247a8711a36903b751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a50a87971f24dc5247a8711a36903b751">lubksb</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;a, const int &amp;n, int indx[], qreal b[])</td></tr>
<tr class="memdesc:a50a87971f24dc5247a8711a36903b751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the set of n linear equations A·X = b, where A nxn matrix decomposed as L·U (L lower triangular and U upper triangular) by forward substitution and backsubstitution.  <br /></td></tr>
<tr class="separator:a50a87971f24dc5247a8711a36903b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721047b8a8639b22617cd7716de60f2d" id="r_a721047b8a8639b22617cd7716de60f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a721047b8a8639b22617cd7716de60f2d">distancesMatrix</a> (const int &amp;metric, const QString varLocation, const bool &amp;diagonal, const bool &amp;considerWeights)</td></tr>
<tr class="memdesc:a721047b8a8639b22617cd7716de60f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dissimilarities matrix of the variables (rows, columns, both) of this matrix using the user defined metric.  <br /></td></tr>
<tr class="separator:a721047b8a8639b22617cd7716de60f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861fc71860b0c52566eb4b5e5ddd13c4" id="r_a861fc71860b0c52566eb4b5e5ddd13c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a861fc71860b0c52566eb4b5e5ddd13c4">similarityMatrix</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;AM, const int &amp;measure, const QString varLocation=&quot;Rows&quot;, const bool &amp;diagonal=false, const bool &amp;considerWeights=true)</td></tr>
<tr class="memdesc:a861fc71860b0c52566eb4b5e5ddd13c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pair-wise matching score of the rows, columns or both of the given matrix AM, based on the given matching measure and returns the similarity matrix.  <br /></td></tr>
<tr class="separator:a861fc71860b0c52566eb4b5e5ddd13c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27c4f1d20bc4717d784b0176d61ff33" id="r_ab27c4f1d20bc4717d784b0176d61ff33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ab27c4f1d20bc4717d784b0176d61ff33">pearsonCorrelationCoefficients</a> (<a class="el" href="classMatrix.html">Matrix</a> &amp;AM, const QString &amp;varLocation=&quot;Rows&quot;, const bool &amp;diagonal=false)</td></tr>
<tr class="memdesc:ab27c4f1d20bc4717d784b0176d61ff33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Pearson Correlation Coefficient of the rows or the columns of the given matrix AM.  <br /></td></tr>
<tr class="separator:ab27c4f1d20bc4717d784b0176d61ff33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f283984f1ffea03ff83bd14c06529e" id="r_a22f283984f1ffea03ff83bd14c06529e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a22f283984f1ffea03ff83bd14c06529e">printHTMLTable</a> (QTextStream &amp;os, const bool markDiag=false, const bool &amp;plain=false, const bool &amp;printInfinity=true)</td></tr>
<tr class="memdesc:a22f283984f1ffea03ff83bd14c06529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints this matrix as HTML table This has the problem that the real actorNumber != elementLabel i.e. when we have deleted a node/vertex.  <br /></td></tr>
<tr class="separator:a22f283984f1ffea03ff83bd14c06529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95d4b525ae65103fff67a94e2d4bcd4" id="r_ad95d4b525ae65103fff67a94e2d4bcd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#ad95d4b525ae65103fff67a94e2d4bcd4">printMatrixConsole</a> (bool debug=true)</td></tr>
<tr class="memdesc:ad95d4b525ae65103fff67a94e2d4bcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints this matrix to stderr or stdout.  <br /></td></tr>
<tr class="separator:ad95d4b525ae65103fff67a94e2d4bcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ed03d8373835e23cc4ca5a4c9b38e6" id="r_a67ed03d8373835e23cc4ca5a4c9b38e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a67ed03d8373835e23cc4ca5a4c9b38e6">illDefined</a> ()</td></tr>
<tr class="memdesc:a67ed03d8373835e23cc4ca5a4c9b38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if matrix is ill-defined (contains at least an inf element)  <br /></td></tr>
<tr class="separator:a67ed03d8373835e23cc4ca5a4c9b38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a60c5ba9f9ca2c6fa3655133f6ef0acdb" id="r_a60c5ba9f9ca2c6fa3655133f6ef0acdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixRow.html">MatrixRow</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a60c5ba9f9ca2c6fa3655133f6ef0acdb">row</a></td></tr>
<tr class="separator:a60c5ba9f9ca2c6fa3655133f6ef0acdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb8d22211af56adfd2a7c8b7cc6f5d2" id="r_a5bb8d22211af56adfd2a7c8b7cc6f5d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a5bb8d22211af56adfd2a7c8b7cc6f5d2">m_rows</a></td></tr>
<tr class="separator:a5bb8d22211af56adfd2a7c8b7cc6f5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c66cddcf56fa64732c07bcaf88077b5" id="r_a5c66cddcf56fa64732c07bcaf88077b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a5c66cddcf56fa64732c07bcaf88077b5">m_cols</a></td></tr>
<tr class="separator:a5c66cddcf56fa64732c07bcaf88077b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0679b655926c60b09c665c5654374c11" id="r_a0679b655926c60b09c665c5654374c11"><td class="memItemLeft" align="right" valign="top">QTextStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrix.html#a0679b655926c60b09c665c5654374c11">operator&lt;&lt;</a> (QTextStream &amp;os, <a class="el" href="classMatrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a0679b655926c60b09c665c5654374c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints matrix m to given textstream.  <br /></td></tr>
<tr class="separator:a0679b655926c60b09c665c5654374c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9b5cc0016481d9e834a1b116507ca5f0" name="a9b5cc0016481d9e834a1b116507ca5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5cc0016481d9e834a1b116507ca5f0">&#9670;&#160;</a></span>Matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowDim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colDim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html#a9b5cc0016481d9e834a1b116507ca5f0" title="Matrix::Matrix Default constructor - creates a Matrix of given dimension (0x0) Use resize(m,...">Matrix::Matrix</a> Default constructor - creates a <a class="el" href="classMatrix.html">Matrix</a> of given dimension (0x0) Use resize(m,n) or zeromatrix(m,n) to resize it. </p>
<p>default constructor - default rows = cols = 0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actors</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a086a20e89f81f1e6f1807e8198993620" name="a086a20e89f81f1e6f1807e8198993620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086a20e89f81f1e6f1807e8198993620">&#9670;&#160;</a></span>Matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html#a9b5cc0016481d9e834a1b116507ca5f0" title="Matrix::Matrix Default constructor - creates a Matrix of given dimension (0x0) Use resize(m,...">Matrix::Matrix</a> Copy constructor. Creates a <a class="el" href="classMatrix.html">Matrix</a> identical to <a class="el" href="classMatrix.html">Matrix</a> b Allows <a class="el" href="classMatrix.html">Matrix</a> a=b declaration Every <a class="el" href="classMatrixRow.html">MatrixRow</a> object holds max_int=32762. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1c3627f573d78a2f08623fdfef990f" name="a9b1c3627f573d78a2f08623fdfef990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1c3627f573d78a2f08623fdfef990f">&#9670;&#160;</a></span>~Matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix::~Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html#a9b1c3627f573d78a2f08623fdfef990f" title="Matrix::~Matrix Destructor.">Matrix::~Matrix</a> Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0e2adb05e204d5a40cd129d9fb0593f" name="ac0e2adb05e204d5a40cd129d9fb0593f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e2adb05e204d5a40cd129d9fb0593f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears data. </p>

</div>
</div>
<a id="ab6d72e265a32cf6fc0256392a076d647" name="ab6d72e265a32cf6fc0256392a076d647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d72e265a32cf6fc0256392a076d647">&#9670;&#160;</a></span>clearItem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::clearItem </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the (r,c) matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3caf2889831de95e3e045c60f8db0122" name="a3caf2889831de95e3e045c60f8db0122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf2889831de95e3e045c60f8db0122">&#9670;&#160;</a></span>cocitationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::cocitationMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Cocitation <a class="el" href="classMatrix.html">Matrix</a> of this matrix (C = A * A^T) Allows T = A.cocitationMatrix() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> T </dd></dl>

</div>
</div>
<a id="a35649f43610688d020b2cad91f616d51" name="a35649f43610688d020b2cad91f616d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35649f43610688d020b2cad91f616d51">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab270bc5fddb676f9f54e4a29ed2162f9" name="ab270bc5fddb676f9f54e4a29ed2162f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270bc5fddb676f9f54e4a29ed2162f9">&#9670;&#160;</a></span>degreeMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::degreeMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Degree <a class="el" href="classMatrix.html">Matrix</a> of this matrix. The Degree <a class="el" href="classMatrix.html">Matrix</a> is diagonal matrix which contains information about the degree of each graph vertex (row of the adjacency matrix) Allows S = A.degreeMatrix() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> S </dd></dl>

</div>
</div>
<a id="ad031e4cac2d7564347c8870cfb08e840" name="ad031e4cac2d7564347c8870cfb08e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad031e4cac2d7564347c8870cfb08e840">&#9670;&#160;</a></span>deleteRowColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::deleteRowColumn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>erased</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes row and column and shifts rows and cols accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">erased</td><td>row/col to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68fc9e95ee2d9d9b18a12abdc95e27dd" name="a68fc9e95ee2d9d9b18a12abdc95e27dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fc9e95ee2d9d9b18a12abdc95e27dd">&#9670;&#160;</a></span>distanceEuclidean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal Matrix::distanceEuclidean </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function, computes the Euclideian length (also known as L2 distance) of a vector: if x = (x1 x2 ... xn), then ||x|| = square_root(x1*x1 + x2*x2 + ... + xn*xn) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a772e644ebf88c4db20141d9453892d84" name="a772e644ebf88c4db20141d9453892d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772e644ebf88c4db20141d9453892d84">&#9670;&#160;</a></span>distanceManhattan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal Matrix::distanceManhattan </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function, takes to vectors and returns their Manhattan distance (also known as l1 norm, Taxicab or L1 distance) which is the sum of the absolute differences of their coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a721047b8a8639b22617cd7716de60f2d" name="a721047b8a8639b22617cd7716de60f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721047b8a8639b22617cd7716de60f2d">&#9670;&#160;</a></span>distancesMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::distancesMatrix </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString&#160;</td>
          <td class="paramname"><em>varLocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>considerWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the dissimilarities matrix of the variables (rows, columns, both) of this matrix using the user defined metric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td></td></tr>
    <tr><td class="paramname">varLocation</td><td></td></tr>
    <tr><td class="paramname">diagonal</td><td></td></tr>
    <tr><td class="paramname">considerWeights</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0f3d752d7b307582b5c34af1cc468df7" name="a0f3d752d7b307582b5c34af1cc468df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3d752d7b307582b5c34af1cc468df7">&#9670;&#160;</a></span>expBySquaring2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::expBySquaring2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive algorithm implementing "Exponentiation by squaring". Also known as Fast Modulo Multiplication, this algorithm allows fast computation of a large power n of square matrix X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Y</td><td>must be the Identity matrix on first call </td></tr>
    <tr><td class="paramname">X</td><td>the matrix to be powered </td></tr>
    <tr><td class="paramname">n</td><td>the power </td></tr>
    <tr><td class="paramname">symmetry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a>&amp;</dd></dl>
<p>On first call, parameters must be: Y=I, X the orginal matrix to power and n the power. Returns the power of matrix X to this object. For n &gt; 4 it is more efficient than naively multiplying the base with itself repeatedly. </p>

</div>
</div>
<a id="a335ff4e4b97b1f412b6ba94fc57ab7a2" name="a335ff4e4b97b1f412b6ba94fc57ab7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335ff4e4b97b1f412b6ba94fc57ab7a2">&#9670;&#160;</a></span>fillMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::fillMatrix </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a matrix with a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48d85988859bc436cbb69b0111f2ca5" name="ab48d85988859bc436cbb69b0111f2ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48d85988859bc436cbb69b0111f2ca5">&#9670;&#160;</a></span>findMinMaxValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::findMinMaxValues </td>
          <td>(</td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>hasRealNumbers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds Min-Max values in current <a class="el" href="classMatrix.html">Matrix</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>value in the matrix </td></tr>
    <tr><td class="paramname">max</td><td>value Complexity: O(n^2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50e3219050552b2f9683be6a4662292b" name="a50e3219050552b2f9683be6a4662292b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e3219050552b2f9683be6a4662292b">&#9670;&#160;</a></span>identityMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::identityMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this square matrix the identity square matrix I. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67ed03d8373835e23cc4ca5a4c9b38e6" name="a67ed03d8373835e23cc4ca5a4c9b38e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ed03d8373835e23cc4ca5a4c9b38e6">&#9670;&#160;</a></span>illDefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::illDefined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if matrix is ill-defined (contains at least an inf element) </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a30645e0907e08bd26a92607773d20f4d" name="a30645e0907e08bd26a92607773d20f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30645e0907e08bd26a92607773d20f4d">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the inverse of given matrix a Allows b.inverse(a) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab1ec5d4a1f06ad0c8a9787e73641a9a9" name="ab1ec5d4a1f06ad0c8a9787e73641a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec5d4a1f06ad0c8a9787e73641a9a9">&#9670;&#160;</a></span>inverseByGaussJordanElimination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::inverseByGaussJordanElimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts given matrix A by Gauss Jordan elimination Input: matrix A Output: matrix A becomes unit matrix this becomes the invert of A and is returned back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverse matrix of A </dd></dl>

</div>
</div>
<a id="acf9348504c25d9f54b065c567c9deaef" name="acf9348504c25d9f54b065c567c9deaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9348504c25d9f54b065c567c9deaef">&#9670;&#160;</a></span>item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qreal Matrix::item </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the (r,c) matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a42bf675c54d9282b437a708ad86b37ad" name="a42bf675c54d9282b437a708ad86b37ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bf675c54d9282b437a708ad86b37ad">&#9670;&#160;</a></span>laplacianMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::laplacianMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Laplacian of this matrix. The Laplacian is a NxN matrix L = D - A where D is the degree matrix of A Allows S = A.laplacianMatrix() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> S </dd></dl>

</div>
</div>
<a id="a50a87971f24dc5247a8711a36903b751" name="a50a87971f24dc5247a8711a36903b751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a87971f24dc5247a8711a36903b751">&#9670;&#160;</a></span>lubksb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::lubksb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>b</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the set of n linear equations A·X = b, where A nxn matrix decomposed as L·U (L lower triangular and U upper triangular) by forward substitution and backsubstitution. </p>
<p>Given A = L·U we have A · x = (L · U) · x = L · (U · x) = b So, this routine first solves L · y = b for the vector y by forward substitution and then solves U · x = y for the vector x using backsubstitution</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input matrix a as the LU decomposition of A, returned by the routine ludcmp </td></tr>
    <tr><td class="paramname">n</td><td>input size of matrix </td></tr>
    <tr><td class="paramname">indx</td><td>input vector, records the row permutation, returned by the routine ludcmp </td></tr>
    <tr><td class="paramname">b</td><td>input array as the right-hand side vector B, and output with the solution vector X </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>:</dd></dl>
<p>a, n, and indx are not modified by this routine and can be left in place for successive calls with different right-hand sides b. This routine takes into account the possibility that b will begin with many zero elements, so it is efficient for use in matrix inversion.</p>
<p>Code adapted from Knuth's Numerical Recipes in C, pp 47 </p>

</div>
</div>
<a id="a6a403dce8bf4ee2cbda5cded9b1ff1ab" name="a6a403dce8bf4ee2cbda5cded9b1ff1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a403dce8bf4ee2cbda5cded9b1ff1ab">&#9670;&#160;</a></span>ludcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::ludcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given matrix a, it replaces a by the LU decomposition of a rowwise permutation of itself. Used in combination with lubksb to solve linear equations or invert a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input matrix n x n and output arranged as in Knuth's equation (2.3.14) </td></tr>
    <tr><td class="paramname">n</td><td>input size of matrix </td></tr>
    <tr><td class="paramname">indx</td><td>output vector, records the row permutation effected by the partial pivoting </td></tr>
    <tr><td class="paramname">d</td><td>output as ±1 depending on whether the number of row interchanges was even or odd </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>:</dd></dl>
<p>Code adapted from Knuth's Numerical Recipes in C, pp 46 </p>

</div>
</div>
<a id="a292e782a2e80d0e8582ba6999a8cc737" name="a292e782a2e80d0e8582ba6999a8cc737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292e782a2e80d0e8582ba6999a8cc737">&#9670;&#160;</a></span>multiplyRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::multiplyRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply every element of row by value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afac4817d5f0980756d72092a2c50a36c" name="afac4817d5f0980756d72092a2c50a36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac4817d5f0980756d72092a2c50a36c">&#9670;&#160;</a></span>multiplyScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::multiplyScalar </td>
          <td>(</td>
          <td class="paramtype">const qreal &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar Multiplication. Multiplies this by qreal f and returns the product matrix of the same dim Allows to use P.multiplyScalar(f) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a263c9e49df2a476afec20d2dce404497" name="a263c9e49df2a476afec20d2dce404497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263c9e49df2a476afec20d2dce404497">&#9670;&#160;</a></span>NeighboursNearestFarthest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::NeighboursNearestFarthest </td>
          <td>(</td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>imin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>jmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>imax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>jmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classMatrix.html#ab48d85988859bc436cbb69b0111f2ca5" title="finds Min-Max values in current Matrix">Matrix::findMinMaxValues</a> only it skips r==c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>value. If (r,c) = minimum, it mean that neighbors r and c are the nearest in the matrix/network </td></tr>
    <tr><td class="paramname">max</td><td>value Complexity: O(n^2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae81491e32603914aae2e302a3594faf8" name="ae81491e32603914aae2e302a3594faf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81491e32603914aae2e302a3594faf8">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">qreal Matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a024b6ea1ea94c6293a829689c92cdb" name="a2a024b6ea1ea94c6293a829689c92cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a024b6ea1ea94c6293a829689c92cdb">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> multiplication, operator * Multiplies (right) this matrix with given matrix b. Allows P = A * B where A,B of same dimension and returns product as a reference to the calling object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">symmetry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a02aa856e2460a5110376a3682a20935e" name="a02aa856e2460a5110376a3682a20935e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02aa856e2460a5110376a3682a20935e">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies (right) this m x n matrix with given n x p matrix b and returns the product in the calling matrix which becomes an m x p matrix. This convenience operator *= allows A *= B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">symmetry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ae0ed296536f062f5857e1e5550093890" name="ae0ed296536f062f5857e1e5550093890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ed296536f062f5857e1e5550093890">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> addition, operator + Adds this matrix and B of the same dim and returns the sum S Allows S = A+B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> S </dd></dl>

</div>
</div>
<a id="abb3c8d544c682255888602203ad4f76c" name="abb3c8d544c682255888602203ad4f76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3c8d544c682255888602203ad4f76c">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html#abb3c8d544c682255888602203ad4f76c" title="Matrix::operator += Matrix add another matrix: += Adds to this matrix another matrix B of the same di...">Matrix::operator +=</a> <a class="el" href="classMatrix.html">Matrix</a> add another matrix: += Adds to this matrix another matrix B of the same dim and returns to this Allows A+=B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this </dd></dl>

</div>
</div>
<a id="a982dfa156a7e026fdf32f9cb3a7aa341" name="a982dfa156a7e026fdf32f9cb3a7aa341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982dfa156a7e026fdf32f9cb3a7aa341">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> subtraction, operator - Subtract this matrix - B of the same dim and returns the result S Allows S = A-B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> S </dd></dl>

</div>
</div>
<a id="ae8d865d3beaec2cce97db3dbcfa42646" name="ae8d865d3beaec2cce97db3dbcfa42646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d865d3beaec2cce97db3dbcfa42646">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> equality/assignment , operator = Allows copying a matrix onto another using b=a where b,a matrices Equals two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aaa4a1562ebf9d783834024dc88131631" name="aaa4a1562ebf9d783834024dc88131631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a1562ebf9d783834024dc88131631">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixRow.html">MatrixRow</a> &amp; Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab27c4f1d20bc4717d784b0176d61ff33" name="ab27c4f1d20bc4717d784b0176d61ff33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27c4f1d20bc4717d784b0176d61ff33">&#9670;&#160;</a></span>pearsonCorrelationCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::pearsonCorrelationCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>AM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>varLocation</em> = <code>&quot;Rows&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Pearson Correlation Coefficient of the rows or the columns of the given matrix AM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AM</td><td><a class="el" href="classMatrix.html">Matrix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> nxn with PPC values for every pair of rows/columns of AM </dd></dl>

</div>
</div>
<a id="a82da700fb408afed1883cc70fcfed906" name="a82da700fb408afed1883cc70fcfed906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82da700fb408afed1883cc70fcfed906">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::pow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the n-nth power of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramname">symmetry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> </dd></dl>

</div>
</div>
<a id="a2ad3327d203585b13e758dff8e1ad4a8" name="a2ad3327d203585b13e758dff8e1ad4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad3327d203585b13e758dff8e1ad4a8">&#9670;&#160;</a></span>powerIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::powerIteration </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>xsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xmaxi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal &amp;&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xmini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qreal&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>maxIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the Power method which computes the leading eigenvector x of this matrix, that is the eigenvector corresponding to the largest positive eigenvalue. In the process, it also computes min and max values. Used by Eigenvector Centrality (EVC). We use C arrays instead of std::vectors or anything else, as we know from start the size (n) of vectors x and tmp This approach is faster than using std::vector when n &gt; 1000. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">xsum</td><td></td></tr>
    <tr><td class="paramname">xmax</td><td></td></tr>
    <tr><td class="paramname">xmaxi</td><td></td></tr>
    <tr><td class="paramname">xmin</td><td></td></tr>
    <tr><td class="paramname">xmini</td><td></td></tr>
    <tr><td class="paramname">eps</td><td></td></tr>
    <tr><td class="paramname">maxIter</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22f283984f1ffea03ff83bd14c06529e" name="a22f283984f1ffea03ff83bd14c06529e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f283984f1ffea03ff83bd14c06529e">&#9670;&#160;</a></span>printHTMLTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::printHTMLTable </td>
          <td>(</td>
          <td class="paramtype">QTextStream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>markDiag</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>plain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>printInfinity</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints this matrix as HTML table This has the problem that the real actorNumber != elementLabel i.e. when we have deleted a node/vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td></td></tr>
    <tr><td class="paramname">debug</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad95d4b525ae65103fff67a94e2d4bcd4" name="ad95d4b525ae65103fff67a94e2d4bcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95d4b525ae65103fff67a94e2d4bcd4">&#9670;&#160;</a></span>printMatrixConsole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::printMatrixConsole </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints this matrix to stderr or stdout. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9363be8aae4aa23516e1c3475e4902e9" name="a9363be8aae4aa23516e1c3475e4902e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9363be8aae4aa23516e1c3475e4902e9">&#9670;&#160;</a></span>product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetry</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> Multiplication. Given two matrices A (mxn) and B (nxp) computes their product and stores it to the calling matrix which becomes an m x p matrix Allows P.product(A, B) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td></td></tr>
    <tr><td class="paramname">B</td><td></td></tr>
    <tr><td class="paramname">symmetry</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>i x k matrix </dd></dl>

</div>
</div>
<a id="afdf864c48534cf7e00563c72cadc32a2" name="afdf864c48534cf7e00563c72cadc32a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf864c48534cf7e00563c72cadc32a2">&#9670;&#160;</a></span>productByVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::productByVector </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>in</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>out</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>leftMultiply</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the matrix-by-vector product Ax of this matrix Default product: Ax if leftMultiply=true then it returns the left product xA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input array/vector </td></tr>
    <tr><td class="paramname">out</td><td>output array </td></tr>
    <tr><td class="paramname">leftMultiply</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b7242fbf4ad8f420088894ce4ee0ac" name="a79b7242fbf4ad8f420088894ce4ee0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b7242fbf4ad8f420088894ce4ee0ac">&#9670;&#160;</a></span>productSym()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::productSym </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes two ( N x N ) matrices (symmetric) and outputs an upper triangular matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3f46f39a935b8209013bb6ba1211d3a2" name="a3f46f39a935b8209013bb6ba1211d3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f46f39a935b8209013bb6ba1211d3a2">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::resize </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this matrix to m x n Called before every operation on new matrices. Every <a class="el" href="classMatrixRow.html">MatrixRow</a> object holds max_int=32762. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actors</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add9c23e5ff5e2456a8d48024ab19fe96" name="add9c23e5ff5e2456a8d48024ab19fe96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9c23e5ff5e2456a8d48024ab19fe96">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62f17622afe35fa3f6a0e07fcf08b8d6" name="a62f17622afe35fa3f6a0e07fcf08b8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f17622afe35fa3f6a0e07fcf08b8d6">&#9670;&#160;</a></span>setItem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::setItem </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const qreal&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the (r,c) matrix element calling the setColumn method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
    <tr><td class="paramname">c</td><td></td></tr>
    <tr><td class="paramname">elem</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861fc71860b0c52566eb4b5e5ddd13c4" name="a861fc71860b0c52566eb4b5e5ddd13c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861fc71860b0c52566eb4b5e5ddd13c4">&#9670;&#160;</a></span>similarityMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::similarityMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>AM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>measure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString&#160;</td>
          <td class="paramname"><em>varLocation</em> = <code>&quot;Rows&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>considerWeights</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the pair-wise matching score of the rows, columns or both of the given matrix AM, based on the given matching measure and returns the similarity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AM</td><td><a class="el" href="classMatrix.html">Matrix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> nxn with matching scores for every pair of rows/columns of AM </dd></dl>

</div>
</div>
<a id="a7e960a1c6e8f5aa90dddb18d9394890c" name="a7e960a1c6e8f5aa90dddb18d9394890c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e960a1c6e8f5aa90dddb18d9394890c">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c3c70b5ced4aff37457087c03e50052" name="a9c3c70b5ced4aff37457087c03e50052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3c70b5ced4aff37457087c03e50052">&#9670;&#160;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Matrix::solve </td>
          <td>(</td>
          <td class="paramtype">qreal&#160;</td>
          <td class="paramname"><em>b</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the solution of the set of n linear equations A·x = b Allows A.solve(b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa637521475da1b4e7e215de25b2f6b16" name="aa637521475da1b4e7e215de25b2f6b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa637521475da1b4e7e215de25b2f6b16">&#9670;&#160;</a></span>subtractFromI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::subtractFromI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts this matrix from I and returns. </p>
<dl class="section return"><dt>Returns</dt><dd>I-this to this matrix </dd></dl>

</div>
</div>
<a id="a1e7680b5e35607556088d94101bedf82" name="a1e7680b5e35607556088d94101bedf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7680b5e35607556088d94101bedf82">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classMatrix.html">Matrix</a> addition Takes two (nxn) matrices and returns their sum as a reference to this Same algorithm as operator +, just different interface. In this case, you use something like: c.sum(a,b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac0e73d5e98817e12b82a3f626c8343de" name="ac0e73d5e98817e12b82a3f626c8343de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e73d5e98817e12b82a3f626c8343de">&#9670;&#160;</a></span>swapRows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::swapRows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps row A with row B of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowA</td><td></td></tr>
    <tr><td class="paramname">rowB</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad609fedfd61e93679803bb114e544569" name="ad609fedfd61e93679803bb114e544569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad609fedfd61e93679803bb114e544569">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> &amp; Matrix::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Transpose of this matrix Allows T = A.transpose() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMatrix.html">Matrix</a> T </dd></dl>

</div>
</div>
<a id="acda39cf7bbe9a7409386a6e36cb2f558" name="acda39cf7bbe9a7409386a6e36cb2f558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda39cf7bbe9a7409386a6e36cb2f558">&#9670;&#160;</a></span>zeroMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Matrix::zeroMatrix </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this matrix the zero matrix of size mxn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a0679b655926c60b09c665c5654374c11" name="a0679b655926c60b09c665c5654374c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0679b655926c60b09c665c5654374c11">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QTextStream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">QTextStream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints matrix m to given textstream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td></td></tr>
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a5c66cddcf56fa64732c07bcaf88077b5" name="a5c66cddcf56fa64732c07bcaf88077b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c66cddcf56fa64732c07bcaf88077b5">&#9670;&#160;</a></span>m_cols</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::m_cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bb8d22211af56adfd2a7c8b7cc6f5d2" name="a5bb8d22211af56adfd2a7c8b7cc6f5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb8d22211af56adfd2a7c8b7cc6f5d2">&#9670;&#160;</a></span>m_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Matrix::m_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60c5ba9f9ca2c6fa3655133f6ef0acdb" name="a60c5ba9f9ca2c6fa3655133f6ef0acdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c5ba9f9ca2c6fa3655133f6ef0acdb">&#9670;&#160;</a></span>row</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixRow.html">MatrixRow</a>* Matrix::row</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/dimitris/socnetv/app/src/<a class="el" href="matrix_8h_source.html">matrix.h</a></li>
<li>/home/dimitris/socnetv/app/src/<a class="el" href="matrix_8cpp.html">matrix.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMatrix.html">Matrix</a></li>
    <li class="footer">
      &copy; 2024 <a href="https://socnetv.org" target="_blank" style="color: white; text-decoration: none;"><strong>Social Network Visualizer</strong></a> - All Rights Reserved - 
      Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
